{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as React from 'react';\nimport { TextField } from '../TextField';\nimport { autobind, BaseComponent, KeyCodes } from '../../../Utilities';\nimport { clearNext, clearPrev, clearRange, DEFAULT_MASK_FORMAT_CHARS, getLeftFormatIndex, getMaskDisplay, getRightFormatIndex, insertString, parseMask } from './inputMask';\nexport var DEFAULT_MASK_CHAR = '_';\n\nvar MaskedTextField =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(MaskedTextField, _super);\n\n  function MaskedTextField(props) {\n    var _this = _super.call(this, props) || this;\n    /**\r\n     * Tell BaseComponent to bypass resolution of componentRef.\r\n     */\n\n\n    _this._skipComponentRefResolution = true; // Translate mask into charData\n\n    _this._maskCharData = parseMask(props.mask, props.maskFormat); // If an initial value is provided, use it to populate the format chars\n\n    props.value && _this.setValue(props.value);\n    _this._isFocused = false;\n    _this._moveCursorOnMouseUp = false;\n    _this.state = {\n      displayValue: getMaskDisplay(props.mask, _this._maskCharData, props.maskChar)\n    };\n    return _this;\n  }\n\n  MaskedTextField.prototype.componentWillReceiveProps = function (newProps) {\n    if (newProps.mask !== this.props.mask) {\n      this._maskCharData = parseMask(newProps.mask, newProps.maskFormat);\n      this.state = {\n        displayValue: getMaskDisplay(newProps.mask, this._maskCharData, newProps.maskChar)\n      };\n    }\n  };\n\n  MaskedTextField.prototype.componentDidUpdate = function () {\n    // Move the cursor to the start of the mask format on update\n    if (this.state.maskCursorPosition !== undefined) {\n      this._textField.setSelectionRange(this.state.maskCursorPosition, this.state.maskCursorPosition);\n    }\n  };\n\n  MaskedTextField.prototype.render = function () {\n    return React.createElement(TextField, tslib_1.__assign({}, this.props, {\n      onFocus: this._onFocus,\n      onBlur: this._onBlur,\n      onMouseDown: this._onMouseDown,\n      onMouseUp: this._onMouseUp,\n      onChange: this._onInputChange,\n      onBeforeChange: this._onBeforeChange,\n      onKeyDown: this._onKeyDown,\n      onPaste: this._onPaste,\n      value: this.state.displayValue,\n      componentRef: this._resolveRef('_textField')\n    }));\n  };\n\n  Object.defineProperty(MaskedTextField.prototype, \"value\", {\n    /**\r\n     * @returns The value of all filled format characters or undefined if not all format characters are filled\r\n     */\n    get: function get() {\n      var value = '';\n\n      for (var i = 0; i < this._maskCharData.length; i++) {\n        if (!this._maskCharData[i].value) {\n          return undefined;\n        }\n\n        value += this._maskCharData[i].value;\n      }\n\n      return value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   *\r\n   */\n\n  MaskedTextField.prototype.setValue = function (newValue) {\n    var valueIndex = 0,\n        charDataIndex = 0;\n\n    while (valueIndex < newValue.length && charDataIndex < this._maskCharData.length) {\n      // Test if the next character in the new value fits the next format character\n      var testVal = newValue[valueIndex];\n\n      if (this._maskCharData[charDataIndex].format.test(testVal)) {\n        this._maskCharData[charDataIndex].value = testVal;\n        charDataIndex++;\n      }\n\n      valueIndex++;\n    }\n  };\n\n  MaskedTextField.prototype.focus = function () {\n    this._textField && this._textField.focus();\n  };\n\n  MaskedTextField.prototype.blur = function () {\n    this._textField && this._textField.blur();\n  };\n\n  MaskedTextField.prototype.select = function () {\n    this._textField && this._textField.select();\n  };\n\n  MaskedTextField.prototype.setSelectionStart = function (value) {\n    this._textField && this._textField.setSelectionStart(value);\n  };\n\n  MaskedTextField.prototype.setSelectionEnd = function (value) {\n    this._textField && this._textField.setSelectionEnd(value);\n  };\n\n  MaskedTextField.prototype.setSelectionRange = function (start, end) {\n    this._textField && this._textField.setSelectionRange(start, end);\n  };\n\n  Object.defineProperty(MaskedTextField.prototype, \"selectionStart\", {\n    get: function get() {\n      return this._textField && this._textField.selectionStart !== null ? this._textField.selectionStart : -1;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MaskedTextField.prototype, \"selectionEnd\", {\n    get: function get() {\n      return this._textField && this._textField.selectionEnd ? this._textField.selectionEnd : -1;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MaskedTextField.prototype._onFocus = function (event) {\n    if (this.props.onFocus) {\n      this.props.onFocus(event);\n    }\n\n    this._isFocused = true; // Move the cursor position to the leftmost unfilled position\n\n    for (var i = 0; i < this._maskCharData.length; i++) {\n      if (!this._maskCharData[i].value) {\n        this.setState({\n          maskCursorPosition: this._maskCharData[i].displayIndex\n        });\n        break;\n      }\n    }\n  };\n\n  MaskedTextField.prototype._onBlur = function (event) {\n    if (this.props.onBlur) {\n      this.props.onBlur(event);\n    }\n\n    this._isFocused = false;\n    this._moveCursorOnMouseUp = true;\n  };\n\n  MaskedTextField.prototype._onMouseDown = function (event) {\n    if (this.props.onMouseDown) {\n      this.props.onMouseDown(event);\n    }\n\n    if (!this._isFocused) {\n      this._moveCursorOnMouseUp = true;\n    }\n  };\n\n  MaskedTextField.prototype._onMouseUp = function (event) {\n    if (this.props.onMouseUp) {\n      this.props.onMouseUp(event);\n    } // Move the cursor on mouseUp after focusing the textField\n\n\n    if (this._moveCursorOnMouseUp) {\n      this._moveCursorOnMouseUp = false; // Move the cursor position to the rightmost unfilled position\n\n      for (var i = 0; i < this._maskCharData.length; i++) {\n        if (!this._maskCharData[i].value) {\n          this.setState({\n            maskCursorPosition: this._maskCharData[i].displayIndex\n          });\n          break;\n        }\n      }\n    }\n  };\n\n  MaskedTextField.prototype._onBeforeChange = function (value) {\n    if (this.props.onBeforeChange) {\n      this.props.onBeforeChange(value);\n    }\n\n    if (this._changeSelectionData === null) {\n      this._changeSelectionData = {\n        changeType: 'default',\n        selectionStart: this._textField.selectionStart !== null ? this._textField.selectionStart : -1,\n        selectionEnd: this._textField.selectionEnd !== null ? this._textField.selectionEnd : -1\n      };\n    }\n  };\n\n  MaskedTextField.prototype._onInputChange = function (ev, value) {\n    if (!this._changeSelectionData) {\n      return;\n    }\n\n    var displayValue = this.state.displayValue; // The initial value of cursorPos does not matter\n\n    var cursorPos = 0;\n    var _a = this._changeSelectionData,\n        changeType = _a.changeType,\n        selectionStart = _a.selectionStart,\n        selectionEnd = _a.selectionEnd;\n\n    if (changeType === 'textPasted') {\n      var charsSelected = selectionEnd - selectionStart,\n          charCount = value.length + charsSelected - displayValue.length,\n          startPos = selectionStart,\n          pastedString = value.substr(startPos, charCount); // Clear any selected characters\n\n      if (charsSelected) {\n        this._maskCharData = clearRange(this._maskCharData, selectionStart, charsSelected);\n      }\n\n      cursorPos = insertString(this._maskCharData, startPos, pastedString);\n    } else if (changeType === 'delete' || changeType === 'backspace') {\n      // isDel is true If the characters are removed LTR, otherwise RTL\n      var isDel = changeType === 'delete',\n          charCount = selectionEnd - selectionStart;\n\n      if (charCount) {\n        // charCount is > 0 if range was deleted\n        this._maskCharData = clearRange(this._maskCharData, selectionStart, charCount);\n        cursorPos = getRightFormatIndex(this._maskCharData, selectionStart);\n      } else {\n        // If charCount === 0, there was no selection and a single character was deleted\n        if (isDel) {\n          this._maskCharData = clearNext(this._maskCharData, selectionStart);\n          cursorPos = getRightFormatIndex(this._maskCharData, selectionStart);\n        } else {\n          this._maskCharData = clearPrev(this._maskCharData, selectionStart);\n          cursorPos = getLeftFormatIndex(this._maskCharData, selectionStart);\n        }\n      }\n    } else if (value.length > displayValue.length) {\n      // This case is if the user added characters\n      var charCount = value.length - displayValue.length,\n          startPos = selectionEnd - charCount,\n          enteredString = value.substr(startPos, charCount);\n      cursorPos = insertString(this._maskCharData, startPos, enteredString);\n    } else if (value.length <= displayValue.length) {\n      /**\r\n       * This case is reached only if the user has selected a block of 1 or more\r\n       * characters and input a character replacing the characters they've selected.\r\n       */\n      var charCount = 1,\n          selectCount = displayValue.length + charCount - value.length,\n          startPos = selectionEnd - charCount,\n          enteredString = value.substr(startPos, charCount); // Clear the selected range\n\n      this._maskCharData = clearRange(this._maskCharData, startPos, selectCount); // Insert the printed character\n\n      cursorPos = insertString(this._maskCharData, startPos, enteredString);\n    }\n\n    this._changeSelectionData = null;\n    var newValue = getMaskDisplay(this.props.mask, this._maskCharData, this.props.maskChar);\n    this.setState({\n      displayValue: newValue,\n      maskCursorPosition: cursorPos\n    }); // Perform onChange/d after input has been processed. Return value is expected to be the displayed text\n\n    if (this.props.onChange) {\n      this.props.onChange(ev, newValue);\n    }\n\n    if (this.props.onChanged) {\n      this.props.onChanged(newValue);\n    }\n  };\n\n  MaskedTextField.prototype._onKeyDown = function (event) {\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(event);\n    }\n\n    this._changeSelectionData = null;\n\n    if (this._textField.value) {\n      var keyCode = event.keyCode,\n          ctrlKey = event.ctrlKey,\n          metaKey = event.metaKey; // Ignore ctrl and meta keydown\n\n      if (ctrlKey || metaKey) {\n        return;\n      } // On backspace or delete, store the selection and the keyCode\n\n\n      if (keyCode === KeyCodes.backspace || keyCode === KeyCodes.del) {\n        var selectionStart = event.target.selectionStart,\n            selectionEnd = event.target.selectionEnd; // Check if backspace or delete press is valid.\n\n        if (!(keyCode === KeyCodes.backspace && selectionEnd && selectionEnd > 0) && !(keyCode === KeyCodes.del && selectionStart !== null && selectionStart < this._textField.value.length)) {\n          return;\n        }\n\n        this._changeSelectionData = {\n          changeType: keyCode === KeyCodes.backspace ? 'backspace' : 'delete',\n          selectionStart: selectionStart !== null ? selectionStart : -1,\n          selectionEnd: selectionEnd !== null ? selectionEnd : -1\n        };\n      }\n    }\n  };\n\n  MaskedTextField.prototype._onPaste = function (event) {\n    if (this.props.onPaste) {\n      this.props.onPaste(event);\n    }\n\n    var selectionStart = event.target.selectionStart,\n        selectionEnd = event.target.selectionEnd; // Store the paste selection range\n\n    this._changeSelectionData = {\n      changeType: 'textPasted',\n      selectionStart: selectionStart !== null ? selectionStart : -1,\n      selectionEnd: selectionEnd !== null ? selectionEnd : -1\n    };\n  };\n\n  MaskedTextField.defaultProps = {\n    maskChar: DEFAULT_MASK_CHAR,\n    maskFormat: DEFAULT_MASK_FORMAT_CHARS\n  };\n\n  tslib_1.__decorate([autobind], MaskedTextField.prototype, \"_onFocus\", null);\n\n  tslib_1.__decorate([autobind], MaskedTextField.prototype, \"_onBlur\", null);\n\n  tslib_1.__decorate([autobind], MaskedTextField.prototype, \"_onMouseDown\", null);\n\n  tslib_1.__decorate([autobind], MaskedTextField.prototype, \"_onMouseUp\", null);\n\n  tslib_1.__decorate([autobind], MaskedTextField.prototype, \"_onBeforeChange\", null);\n\n  tslib_1.__decorate([autobind], MaskedTextField.prototype, \"_onInputChange\", null);\n\n  tslib_1.__decorate([autobind], MaskedTextField.prototype, \"_onKeyDown\", null);\n\n  tslib_1.__decorate([autobind], MaskedTextField.prototype, \"_onPaste\", null);\n\n  return MaskedTextField;\n}(BaseComponent);\n\nexport { MaskedTextField };","map":null,"metadata":{},"sourceType":"module"}
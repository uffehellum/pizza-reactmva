{"ast":null,"code":"/**\r\n * asAsync - a HOC for async loading components.\r\n *\r\n * Usage:\r\n *\r\n * const AsyncDialog = asAsync({\r\n *   load: () => import('Dialog').then(result => result.default),\r\n * });\r\n *\r\n * React.render(domElement, <AsyncDialog asyncPlaceholder={ () => <Spinner/> } { ...dialogProps } />);\r\n *\r\n * Note the `asyncPlaceholder` prop will be respected when rendering the async component and it hasn't\r\n * been loaded yet.\r\n */\nimport * as tslib_1 from \"tslib\";\nimport * as React from 'react';\n/**\r\n * If possible, use a WeakMap to maintain a cache of loaded components.\r\n * This can be used to synchronously render components that have already been loaded,\r\n * rather than having to wait for at least one async tick.\r\n */\n\nvar _syncModuleCache = typeof WeakMap !== 'undefined' ? // tslint:disable-next-line:no-any\nnew WeakMap() : undefined;\n/**\r\n * Produces a component which internally loads the target component before first mount.\r\n * The component passes all props through to the loaded component.\r\n *\r\n * This overload accepts a module with a default export for the component.\r\n */\n\n\nexport function asAsync(options) {\n  var Async =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(Async, _super);\n\n    function Async() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n\n      _this.state = {\n        Component: _syncModuleCache ? _syncModuleCache.get(options.load) : undefined\n      };\n      return _this;\n    }\n\n    Async.prototype.render = function () {\n      // Typescript issue: the rest can't be pulled without the any cast, as TypeScript fails with rest on generics.\n      // tslint:disable-next-line:no-any\n      var _a = this.props,\n          forwardedRef = _a.forwardedRef,\n          Placeholder = _a.asyncPlaceholder,\n          rest = tslib_1.__rest(_a, [\"forwardedRef\", \"asyncPlaceholder\"]);\n\n      var Component = this.state.Component;\n      return Component ? React.createElement(Component, tslib_1.__assign({\n        ref: forwardedRef\n      }, rest)) : Placeholder ? React.createElement(Placeholder, null) : null;\n    };\n\n    Async.prototype.componentDidMount = function () {\n      var _this = this;\n\n      var Component = this.state.Component;\n\n      if (!Component) {\n        options.load().then(function (LoadedComponent) {\n          if (LoadedComponent) {\n            // Cache component for future reference.\n            _syncModuleCache && _syncModuleCache.set(options.load, LoadedComponent); // Set state.\n\n            _this.setState({\n              Component: LoadedComponent\n            }, options.onLoad);\n          }\n        }).catch(options.onError);\n      }\n    };\n\n    return Async;\n  }(React.Component);\n\n  return React.forwardRef(function (props, ref) {\n    return React.createElement(Async, tslib_1.__assign({}, props, {\n      forwardedRef: ref\n    }));\n  });\n}","map":null,"metadata":{},"sourceType":"module"}
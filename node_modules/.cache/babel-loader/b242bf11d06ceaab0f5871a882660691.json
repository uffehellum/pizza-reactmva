{"ast":null,"code":"var now = function now() {\n  return typeof performance !== 'undefined' && !!performance.now ? performance.now() : Date.now();\n};\n\nvar RESET_INTERVAL = 3 * 60 * 1000; // auto reset every 3 minutes\n\n/**\r\n * Performance helper class for measuring things.\r\n *\r\n * @public\r\n */\n\nvar FabricPerformance =\n/** @class */\nfunction () {\n  function FabricPerformance() {}\n  /**\r\n   * Measures execution time of the given syncronous function. If the same logic is executed multiple times,\r\n   * each individual measurement will be collected as well the overall numbers.\r\n   * @param name - The name of this measurement\r\n   * @param func - The logic to be measured for execution time\r\n   */\n\n\n  FabricPerformance.measure = function (name, func) {\n    if (FabricPerformance._timeoutId) {\n      FabricPerformance.setPeriodicReset();\n    }\n\n    var start = now();\n    func();\n    var end = now();\n    var measurement = FabricPerformance.summary[name] || {\n      totalDuration: 0,\n      count: 0,\n      all: []\n    };\n    var duration = end - start;\n    measurement.totalDuration += duration;\n    measurement.count++;\n    measurement.all.push({\n      duration: duration,\n      timeStamp: end\n    });\n    FabricPerformance.summary[name] = measurement;\n  };\n\n  FabricPerformance.reset = function () {\n    FabricPerformance.summary = {};\n    clearTimeout(FabricPerformance._timeoutId);\n    FabricPerformance._timeoutId = NaN;\n  };\n\n  FabricPerformance.setPeriodicReset = function () {\n    FabricPerformance._timeoutId = setTimeout(function () {\n      return FabricPerformance.reset();\n    }, RESET_INTERVAL);\n  };\n\n  FabricPerformance.summary = {};\n  return FabricPerformance;\n}();\n\nexport { FabricPerformance };","map":null,"metadata":{},"sourceType":"module"}
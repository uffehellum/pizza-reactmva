define(["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DATA_PORTAL_ATTRIBUTE = 'data-portal-element';
    /**
     * Sets the virtual parent of an element.
     * Pass `undefined` as the `parent` to clear the virtual parent.
     *
     * @public
     */
    function setVirtualParent(child, parent) {
        var virtualChild = child;
        var virtualParent = parent;
        if (!virtualChild._virtual) {
            virtualChild._virtual = {
                children: []
            };
        }
        var oldParent = virtualChild._virtual.parent;
        if (oldParent && oldParent !== parent) {
            // Remove the child from its old parent.
            var index = oldParent._virtual.children.indexOf(virtualChild);
            if (index > -1) {
                oldParent._virtual.children.splice(index, 1);
            }
        }
        virtualChild._virtual.parent = virtualParent || undefined;
        if (virtualParent) {
            if (!virtualParent._virtual) {
                virtualParent._virtual = {
                    children: []
                };
            }
            virtualParent._virtual.children.push(virtualChild);
        }
    }
    exports.setVirtualParent = setVirtualParent;
    /**
     * Gets the virtual parent given the child element, if it exists.
     *
     * @public
     */
    function getVirtualParent(child) {
        var parent;
        if (child && isVirtualElement(child)) {
            parent = child._virtual.parent;
        }
        return parent;
    }
    exports.getVirtualParent = getVirtualParent;
    /**
     * Gets the element which is the parent of a given element.
     * If `allowVirtuaParents` is `true`, this method prefers the virtual parent over
     * real DOM parent when present.
     *
     * @public
     */
    function getParent(child, allowVirtualParents) {
        if (allowVirtualParents === void 0) { allowVirtualParents = true; }
        return child && ((allowVirtualParents && getVirtualParent(child)) || (child.parentNode && child.parentNode));
    }
    exports.getParent = getParent;
    /**
     * Gets the elements which are child elements of the given element.
     * If `allowVirtualChildren` is `true`, this method enumerates virtual child elements
     * after the original children.
     * @param parent - The element to get the children of.
     * @param allowVirtualChildren - true if the method should enumerate virtual child elements.
     */
    function getChildren(parent, allowVirtualChildren) {
        if (allowVirtualChildren === void 0) { allowVirtualChildren = true; }
        var children = [];
        if (parent) {
            for (var i = 0; i < parent.children.length; i++) {
                children.push(parent.children.item(i));
            }
            if (allowVirtualChildren && isVirtualElement(parent)) {
                children.push.apply(children, parent._virtual.children);
            }
        }
        return children;
    }
    exports.getChildren = getChildren;
    /**
     * Determines whether or not a parent element contains a given child element.
     * If `allowVirtualParents` is true, this method may return `true` if the child
     * has the parent in its virtual element hierarchy.
     *
     * @public
     */
    function elementContains(parent, child, allowVirtualParents) {
        if (allowVirtualParents === void 0) { allowVirtualParents = true; }
        var isContained = false;
        if (parent && child) {
            if (allowVirtualParents) {
                isContained = false;
                while (child) {
                    var nextParent = getParent(child);
                    if (nextParent === parent) {
                        isContained = true;
                        break;
                    }
                    child = nextParent;
                }
            }
            else if (parent.contains) {
                isContained = parent.contains(child);
            }
        }
        return isContained;
    }
    exports.elementContains = elementContains;
    var _isSSR = false;
    /**
     * Helper to set ssr mode to simulate no window object returned from getWindow helper.
     *
     * @public
     */
    function setSSR(isEnabled) {
        _isSSR = isEnabled;
    }
    exports.setSSR = setSSR;
    /**
     * Helper to get the window object.
     *
     * @public
     */
    function getWindow(rootElement) {
        if (_isSSR || typeof window === 'undefined') {
            return undefined;
        }
        else {
            return rootElement && rootElement.ownerDocument && rootElement.ownerDocument.defaultView
                ? rootElement.ownerDocument.defaultView
                : window;
        }
    }
    exports.getWindow = getWindow;
    /**
     * Helper to get the document object.
     *
     * @public
     */
    function getDocument(rootElement) {
        if (_isSSR || typeof document === 'undefined') {
            return undefined;
        }
        else {
            return rootElement && rootElement.ownerDocument ? rootElement.ownerDocument : document;
        }
    }
    exports.getDocument = getDocument;
    /**
     * Helper to get bounding client rect, works with window.
     *
     * @public
     */
    function getRect(element) {
        var rect;
        if (element) {
            if (element === window) {
                rect = {
                    left: 0,
                    top: 0,
                    width: window.innerWidth,
                    height: window.innerHeight,
                    right: window.innerWidth,
                    bottom: window.innerHeight
                };
            }
            else if (element.getBoundingClientRect) {
                rect = element.getBoundingClientRect();
            }
        }
        return rect;
    }
    exports.getRect = getRect;
    /**
     * Identify element as a portal by setting an attribute.
     * @param element - Element to mark as a portal.
     */
    function setPortalAttribute(element) {
        element.setAttribute(exports.DATA_PORTAL_ATTRIBUTE, 'true');
    }
    exports.setPortalAttribute = setPortalAttribute;
    /**
     * Determine whether a target is within a portal from perspective of root or optional parent.
     * This function only works against portal components that use the setPortalAttribute function.
     * If both parent and child are within the same portal this function will return false.
     * @param target - Element to query portal containment status of.
     * @param parent - Optional parent perspective. Search for containing portal stops at parent (or root if parent is undefined or invalid.)
     */
    function portalContainsElement(target, parent) {
        var elementMatch = findElementRecursive(target, function (testElement) { return parent === testElement || testElement.hasAttribute(exports.DATA_PORTAL_ATTRIBUTE); });
        return elementMatch !== null && elementMatch.hasAttribute(exports.DATA_PORTAL_ATTRIBUTE);
    }
    exports.portalContainsElement = portalContainsElement;
    /**
     * Finds the first parent element where the matchFunction returns true
     * @param element - element to start searching at
     * @param matchFunction - the function that determines if the element is a match
     * @returns the matched element or null no match was found
     */
    function findElementRecursive(element, matchFunction) {
        if (!element || element === document.body) {
            return null;
        }
        return matchFunction(element) ? element : findElementRecursive(getParent(element), matchFunction);
    }
    exports.findElementRecursive = findElementRecursive;
    /**
     * Determines if an element, or any of its ancestors, contain the given attribute
     * @param element - element to start searching at
     * @param attribute - the attribute to search for
     * @returns the value of the first instance found
     */
    function elementContainsAttribute(element, attribute) {
        var elementMatch = findElementRecursive(element, function (testElement) { return testElement.hasAttribute(attribute); });
        return elementMatch && elementMatch.getAttribute(attribute);
    }
    exports.elementContainsAttribute = elementContainsAttribute;
    /**
     * Determines whether or not an element has the virtual hierarchy extension.
     *
     * @public
     */
    function isVirtualElement(element) {
        return element && !!element._virtual;
    }
});
//# sourceMappingURL=dom.js.map
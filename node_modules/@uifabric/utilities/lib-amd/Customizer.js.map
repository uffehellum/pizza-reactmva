{"version":3,"file":"Customizer.js","sourceRoot":"../src/","sources":["Customizer.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\r\nimport { BaseComponent, IBaseProps } from './BaseComponent';\r\nimport { Customizations, ICustomizations, Settings, SettingsFunction } from './Customizations';\r\n\r\nexport interface ICustomizerContext {\r\n  customizations: ICustomizations;\r\n}\r\n\r\nexport const CustomizerContext = React.createContext<ICustomizerContext>({\r\n  customizations: {\r\n    inCustomizerContext: false,\r\n    settings: {},\r\n    scopedSettings: {}\r\n  }\r\n});\r\n\r\nexport type ICustomizerProps = IBaseProps &\r\n  Partial<{\r\n    /**\r\n     * @description\r\n     * Settings are used as general settings for the React tree below.\r\n     * Components can subscribe to receive the settings by using `customizable`.\r\n     *\r\n     * @example\r\n     * Settings can be represented by a plain object that contains the key value pairs.\r\n     * ```\r\n     *  <Customizer settings={{ color: 'red' }} />\r\n     * ```\r\n     * or a function that receives the current settings and returns the new ones\r\n     * ```\r\n     *  <Customizer settings={(currentSettings) => ({ ...currentSettings, color: 'red' })} />\r\n     * ```\r\n     */\r\n    settings: Settings | SettingsFunction;\r\n    /**\r\n     * @description\r\n     * Scoped settings are settings that are scoped to a specific scope. The\r\n     * scope is the name that is passed to the `customizable` function when the\r\n     * the component is customized.\r\n     *\r\n     * @example\r\n     * Scoped settings can be represented by a plain object that contains the key value pairs.\r\n     * ```\r\n     *  const myScopedSettings = {\r\n     *    Button: { color: 'red' };\r\n     *  };\r\n     *\r\n     *  <Customizer scopedSettings={myScopedSettings} />\r\n     * ```\r\n     * or a function that receives the current settings and returns the new ones\r\n     * ```\r\n     *  const myScopedSettings = {\r\n     *    Button: { color: 'red' };\r\n     *  };\r\n     *\r\n     *  <Customizer scopedSettings={(currentScopedSettings) => ({ ...currentScopedSettings, ...myScopedSettings })} />\r\n     * ```\r\n     */\r\n    scopedSettings: Settings | SettingsFunction;\r\n  }> & {\r\n    /**\r\n     * Optional transform function for context. Any implementations should take care to return context without\r\n     * mutating it.\r\n     */\r\n    contextTransform?: (context: Readonly<ICustomizerContext>) => ICustomizerContext;\r\n  };\r\n\r\n/**\r\n * The Customizer component allows for default props to be mixed into components which\r\n * are decorated with the customizable() decorator, or use the styled HOC. This enables\r\n * injection scenarios like:\r\n *\r\n * 1. render svg icons instead of the icon font within all buttons\r\n * 2. inject a custom theme object into a component\r\n *\r\n * Props are provided via the settings prop which should be one of the following:\r\n * - A json map which contains 1 or more name/value pairs representing injectable props.\r\n * - A function that receives the current settings and returns the new ones that apply to the scope\r\n *\r\n * @public\r\n */\r\nexport class Customizer extends BaseComponent<ICustomizerProps> {\r\n  private _changeCount = 0;\r\n\r\n  public componentDidMount(): void {\r\n    Customizations.observe(this._onCustomizationChange);\r\n  }\r\n\r\n  public componentWillUnmount(): void {\r\n    Customizations.unobserve(this._onCustomizationChange);\r\n  }\r\n\r\n  public render(): React.ReactElement<{}> {\r\n    const { contextTransform } = this.props;\r\n    return (\r\n      <CustomizerContext.Consumer>\r\n        {(parentContext: ICustomizerContext) => {\r\n          let newContext = mergeCustomizations(this.props, parentContext);\r\n\r\n          if (contextTransform) {\r\n            newContext = contextTransform(newContext);\r\n          }\r\n\r\n          return <CustomizerContext.Provider value={newContext}>{this.props.children}</CustomizerContext.Provider>;\r\n        }}\r\n      </CustomizerContext.Consumer>\r\n    );\r\n  }\r\n\r\n  private _onCustomizationChange = () => this.forceUpdate();\r\n}\r\n\r\n/**\r\n * Merge props and customizations giving priority to props over context.\r\n * NOTE: This function will always perform multiple merge operations. Use with caution.\r\n * @param props - New settings to merge in.\r\n * @param parentContext - Context containing current settings.\r\n * @returns Merged customizations.\r\n */\r\nexport function mergeCustomizations(props: ICustomizerProps, parentContext: ICustomizerContext): ICustomizerContext {\r\n  const { customizations = { settings: {}, scopedSettings: {} } } = parentContext || {};\r\n\r\n  return {\r\n    customizations: {\r\n      settings: mergeSettings(customizations.settings, props.settings),\r\n      scopedSettings: mergeScopedSettings(customizations.scopedSettings, props.scopedSettings),\r\n      inCustomizerContext: true\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Merge new and old settings, giving priority to new settings.\r\n * New settings is optional in which case oldSettings is returned as-is.\r\n * @param oldSettings - Old settings to fall back to.\r\n * @param newSettings - New settings that will be merged over oldSettings.\r\n * @returns Merged settings.\r\n */\r\nexport function mergeSettings(oldSettings: Settings = {}, newSettings?: Settings | SettingsFunction): Settings {\r\n  const mergeSettingsWith = isSettingsFunction(newSettings) ? newSettings : settingsMergeWith(newSettings);\r\n\r\n  return mergeSettingsWith(oldSettings);\r\n}\r\n\r\nfunction mergeScopedSettings(oldSettings: Settings = {}, newSettings?: Settings | SettingsFunction): Settings {\r\n  const mergeSettingsWith = isSettingsFunction(newSettings) ? newSettings : scopedSettingsMergeWith(newSettings);\r\n\r\n  return mergeSettingsWith(oldSettings);\r\n}\r\n\r\nfunction isSettingsFunction(settings?: Settings | SettingsFunction): settings is SettingsFunction {\r\n  return typeof settings === 'function';\r\n}\r\n\r\nfunction settingsMergeWith(newSettings?: object): (settings: Settings) => Settings {\r\n  return (settings: Settings) => (newSettings ? { ...settings, ...newSettings } : settings);\r\n}\r\n\r\nfunction scopedSettingsMergeWith(scopedSettingsFromProps: Settings = {}): (scopedSettings: Settings) => Settings {\r\n  return (oldScopedSettings: Settings): Settings => {\r\n    const newScopedSettings: Settings = { ...oldScopedSettings };\r\n\r\n    for (let scopeName in scopedSettingsFromProps) {\r\n      if (scopedSettingsFromProps.hasOwnProperty(scopeName)) {\r\n        newScopedSettings[scopeName] = { ...oldScopedSettings[scopeName], ...scopedSettingsFromProps[scopeName] };\r\n      }\r\n    }\r\n\r\n    return newScopedSettings;\r\n  };\r\n}\r\n"]}